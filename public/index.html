<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Stock Analyzer v.036</title>

<!-- Favicon -->
<link rel="icon" type="image/png" href="/assets/stratus-trader-wide.png">

<!-- Plotly (no defer) -->
<script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>

<style>
  :root{
    --bg:#0f1115;--panel:#151923;--text:#e5e7eb;--muted:#9ca3af;
    --accent:#22c55e;--focus:#3b82f6;--border:#23283a;--hover:#161a25;
    --metric-bg:#1a1f2e;--metric-border:#2a2f3e;
    --field-bg:#0c0f16;--field-text:#e5e7eb;
    --c-up:#16a34a;--c-down:#dc2626;
    --c-sma20:#22c55e;--c-sma50:#60a5fa;--c-sma200:#f59e0b;
    --c-rsi:#a78bfa;--c-macd:#38bdf8;--c-vol:#10b981;
    --grid:#283044;
    --lvl-beginner:#22c55e; --lvl-intermediate:#f59e0b; --lvl-advanced:#ef4444;
    --tf-bg:#1c1f35; --tf-head:#1a214e; --tf-glow:#3b82f6;
    --c-ichi-tenkan:#f59e0b; --c-ichi-kijun:#60a5fa; --c-ichi-chikou:#93c5fd;
    --c-ichi-up:rgba(34,197,94,.38);   /* stronger */
    --c-ichi-down:rgba(239,68,68,.34); /* stronger */
  }
  .light{
    --bg:#f8fafc;--panel:#fff;--text:#222;--muted:#64748b;
    --accent:#22c55e;--focus:#3b82f3;--border:#e2e8f0;--hover:#f1f5f9;
    --metric-bg:#f1f5f9;--metric-border:#e2e8f0;
    --c-up:#16a34a;--c-down:#dc2626;
    --c-sma20:#22c55e;--c-sma50:#2563eb;--c-sma200:#f59e0b;
    --c-rsi:#7c3aed;--c-macd:#0ea5e9;--c-vol:#16a34a;
    --grid:#e5e7eb; --tf-bg:#eef2ff; --tf-head:#c7d2fe; --tf-glow:#6366f1;
    --field-bg:#ffffff; --field-text:#111827;
  }
  *{box-sizing:border-box}
  html,body{overflow-x:hidden}
  body{margin:0;background:var(--bg);color:var(--text);font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;min-height:100vh;padding:20px;transition:background .2s,color .2s}
  .container{max-width:1100px;margin:0 auto}
  .toolbar{position:sticky;top:0;z-index:12000;display:flex;gap:10px;align-items:center;background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:10px 12px;margin-bottom:16px;flex-wrap:wrap}
  .ticker-wrap{display:flex;align-items:center;gap:8px;flex:1;min-width:0}
  .ticker-wrap label{font-weight:800;opacity:.9}
  .input-wrap{position:relative;flex:0 1 460px;max-width:460px;width:100%}
  @media (max-width:720px){ .input-wrap{flex:1 1 100%;max-width:100%} }
  .ticker-input{width:100%;min-width:120px;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:var(--field-bg);color:var(--field-text);text-transform:uppercase;font-size:16px}
  .btn{padding:10px 14px;border:0;border-radius:10px;background:var(--accent);color:#fff;font-weight:800;cursor:pointer}
  .btn.inline{padding:8px 12px}
  .toolsbar{display:flex;align-items:center;gap:8px;margin-left:auto;flex:1 1 100%;justify-content:flex-start;flex-wrap:wrap}
  .tool-btn{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;border:1px solid var(--border);background:var(--panel);color:var(--text);font-weight:700;cursor:pointer}
  .tool-btn:hover{background:var(--hover)}
  .theme-toggle{margin-left:auto;cursor:pointer;padding:8px 14px;border-radius:8px;background:var(--panel);color:var(--text);border:1px solid var(--border);font-weight:600}
  .theme-toggle:hover{background:var(--hover)}
  .theme-toggle.active{background:var(--accent);color:#fff}
  .ac{position:absolute;left:0;top:calc(100% + 6px);width:100%;background:var(--panel);color:var(--text);border:1px solid var(--border);border-radius:10px;display:none;max-height:280px;overflow:auto;box-shadow:0 10px 24px rgba(0,0,0,.18);z-index:12050}
  .ac.show{display:block}
  .ac-item{padding:12px 14px;display:grid;grid-template-columns:110px 1fr;gap:12px;align-items:center;cursor:pointer;border-bottom:1px solid var(--metric-border)}
  .ac-item:hover,.ac-item.active{background:var(--hover)}
  .ticker{font-weight:800}
  .company{color:var(--muted);font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .info{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:14px;margin-bottom:12px;position:relative}
  .info-logo{position:absolute;top:10px;right:12px;height:54px;opacity:.92;pointer-events:none;filter:drop-shadow(0 2px 8px rgba(0,0,0,.35))}
  .light .info-logo{mix-blend-mode:multiply;filter:drop-shadow(0 2px 6px rgba(0,0,0,.12));opacity:.95}
  @media (max-width:640px){ .info-logo{height:42px;right:10px} }
  #chartCard{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:16px;position:relative}
  #chart{height:68vh;min-height:520px}
  .container.wide{max-width:100%!important}
  #chartCard.max{position:fixed;inset:12px;z-index:9999;margin:0!important;width:auto!important;height:auto!important;overflow:auto}
  #chartCard.max #chart{height:calc(100vh - 160px)!important;min-height:400px;cursor:zoom-out}
  .tf-card{background:var(--tf-bg);border:1px solid rgba(99,102,241,.25);border-radius:12px;padding:10px;margin-bottom:10px;box-shadow:0 0 0 1px rgba(99,102,241,.15) inset}
  .tf-head{display:flex;align-items:center;gap:8px;background:linear-gradient(180deg, var(--tf-head), transparent);border-radius:8px;padding:6px 10px;margin:-4px -2px 8px;font-weight:800}
  .tf-head .carat{display:inline-block;transform:rotate(-90deg);transition:transform .15s ease}
  .tf-card[data-open="true"] .carat{transform:rotate(0)}
  .tf-body{display:none}
  .tf-card[data-open="true"] .tf-body{display:grid}
  .tf-body{grid-template-columns:1fr 1fr;gap:10px}
  .control label{display:block;font-size:13px;font-weight:800;margin-bottom:6px;color:#cbd5ff}
  .control select{width:100%;background:var(--field-bg);color:var(--field-text);border:1px solid var(--border);border-radius:10px;padding:10px}
  .toggle-row{display:flex;flex-wrap:wrap;gap:8px;margin:12px 0 10px}
  .chip{border:1px solid #2b3548;border-radius:999px;padding:6px 12px;cursor:pointer;font-weight:700;opacity:.95;user-select:none;transition:background .15s,color .15s,border-color .15s}
  /* Chip base colors ‚Äî all overlays get strong color and glow */
  .chip[data-k="SMA20"]{border-color:var(--c-sma20);color:var(--c-sma20);background:transparent;}
  .chip[data-k="SMA50"]{border-color:var(--c-sma50);color:var(--c-sma50);background:transparent;}
  .chip[data-k="SMA200"]{border-color:var(--c-sma200);color:var(--c-sma200);background:transparent;}
  .chip[data-k="RSI"]{border-color:var(--c-rsi);color:var(--c-rsi);background:transparent;}
  .chip[data-k="MACD"]{border-color:var(--c-macd);color:var(--c-macd);background:transparent;}
  .chip[data-k="VOL"]{border-color:var(--c-vol);color:var(--c-vol);background:transparent;}
  .chip[data-k="AUTOFIB"]{border-color:#8b5cf6;color:#8b5cf6;background:transparent;}
  .chip[data-k="ICHI"]{border-color:#60a5fa;color:#60a5fa;background:transparent;}
  .chip{background:transparent;color:var(--text);}
  .chip.active{color:#fff;background:rgba(255,255,255,0.08);}
  /* Strong halo glow for ACTIVE chips only, using overlay color */
  .chip.active[data-k="SMA20"] {
    --chip-glow: var(--c-sma20, #22c55e);
    box-shadow:
      0 0 0 2px var(--chip-glow),
      0 0 14px 3px var(--chip-glow),
      0 0 36px 10px color-mix(in sRGB, var(--chip-glow) 40%, transparent);
  }
  .chip.active[data-k="SMA50"] {
    --chip-glow: var(--c-sma50, #60a5fa);
    box-shadow:
      0 0 0 2px var(--chip-glow),
      0 0 14px 3px var(--chip-glow),
      0 0 36px 10px color-mix(in sRGB, var(--chip-glow) 40%, transparent);
  }
  .chip.active[data-k="SMA200"] {
    --chip-glow: var(--c-sma200, #f59e0b);
    box-shadow:
      0 0 0 2px var(--chip-glow),
      0 0 14px 3px var(--chip-glow),
      0 0 36px 10px color-mix(in sRGB, var(--chip-glow) 40%, transparent);
  }
  .chip.active[data-k="RSI"] {
    --chip-glow: var(--c-rsi, #a78bfa);
    box-shadow:
      0 0 0 2px var(--chip-glow),
      0 0 14px 3px var(--chip-glow),
      0 0 36px 10px color-mix(in sRGB, var(--chip-glow) 40%, transparent);
  }
  .chip.active[data-k="MACD"] {
    --chip-glow: var(--c-macd, #38bdf8);
    box-shadow:
      0 0 0 2px var(--chip-glow),
      0 0 14px 3px var(--chip-glow),
      0 0 36px 10px color-mix(in sRGB, var(--chip-glow) 40%, transparent);
  }
  .chip.active[data-k="VOL"] {
    --chip-glow: var(--c-vol, #10b981);
    box-shadow:
      0 0 0 2px var(--chip-glow),
      0 0 14px 3px var(--chip-glow),
      0 0 36px 10px color-mix(in sRGB, var(--chip-glow) 40%, transparent);
  }
  .chip.active[data-k="AUTOFIB"] {
    --chip-glow: #8b5cf6;
    box-shadow:
      0 0 0 2px var(--chip-glow),
      0 0 14px 3px var(--chip-glow),
      0 0 36px 10px color-mix(in sRGB, var(--chip-glow) 40%, transparent);
  }
  .chip.active[data-k="ICHI"] {
    --chip-glow: #60a5fa;
    box-shadow:
      0 0 0 2px var(--chip-glow),
      0 0 14px 3px var(--chip-glow),
      0 0 36px 10px color-mix(in sRGB, var(--chip-glow) 40%, transparent);
  }
  .chip.active {
    position: relative;
    z-index: 2;
  }
  .chip.active::after {
    content: "";
    position: absolute;
    inset: -10px;
    border-radius: 999px;
    background: radial-gradient(60% 60% at 50% 50%, var(--chip-glow, #fff) 0%, transparent 75%);
    filter: blur(12px);
    opacity: .45;
    pointer-events: none;
    z-index: 1;
  }
  /* Info bar image fix */
  .info-logo{filter:none;mix-blend-mode:normal;}
  /* Chart overlay text color fix */
  .plotly .legendtext, .plotly .ytick text, .plotly .xtick text { fill: var(--text) !important; }
  .section-sep{margin:20px -16px 16px;padding:0 16px}
  .section-sep .rule{height:3px;border-radius:999px;background:linear-gradient(90deg,var(--focus),var(--accent));opacity:.9}
  .sheet{position:fixed;left:0;right:0;bottom:0;top:auto;background:transparent;display:flex;justify-content:center;z-index:2000}
  .sheet[hidden]{display:none!important}
  .sheet-inner{width:min(760px,100%);background:var(--panel);border-top:1px solid var(--border);border-radius:16px 16px 0 0;box-shadow:0 -8px 30px rgba(0,0,0,.35);padding:14px;animation:sheetUp .18s ease-out;padding-bottom:max(14px, env(safe-area-inset-bottom))}
  .sheet-head{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
  .sheet-title{font-weight:800;font-size:16px}
  .sheet-close{background:transparent;border:0;color:var(--text);font-size:18px;cursor:pointer}
  .sheet-body{max-height:58vh;overflow:auto}
  @keyframes sheetUp{from{transform:translateY(16px);opacity:0}to{transform:translateY(0);opacity:1}}
  .btmnav{position:fixed;left:0;right:0;bottom:0;display:none;background:var(--panel);border-top:1px solid var(--border);padding:6px 10px;z-index:1000}
  .btmnav .tab{flex:1;display:flex;flex-direction:column;align-items:center;gap:4px;padding:6px 8px;border-radius:10px;border:0;background:transparent;color:var(--text);font-weight:700;font-size:13px}
  .btmnav .tab.active{background:var(--hover)}
  .btmnav .tab span{font-size:11px;opacity:.85}
  @media (max-width:720px){ .btmnav{display:flex;gap:8px} body{padding-bottom:64px} }
  .scr-list{display:flex;flex-direction:column;gap:10px}
  .scr-item{
    position:relative; display:flex; gap:12px; align-items:flex-start;
    padding:12px 14px; border:1px solid var(--border); border-radius:12px;
    background:color-mix(in hsl, var(--panel), var (--bg) 35%);
    text-decoration:none; color:inherit; cursor:pointer;
    transition:background .15s,border-color .15s,transform .06s;
  }
  .scr-item:hover{ background:var(--hover); border-color:#2b3548; transform:translateY(-1px); }
  .scr-item::before{ content:""; position:absolute; left:0; top:8px; bottom:8px; width:4px; border-radius:999px; background: var(--lvl-color, #64748b); opacity:.8; }
  .scr-item{ padding-left:16px; }
  .scr-item[data-lvl="Beginner"]     { --lvl-color: var(--lvl-beginner); }
  .scr-item[data-lvl="Intermediate"] { --lvl-color: var(--lvl-intermediate); }
  .scr-item[data-lvl="Advanced"]     { --lvl-color: var(--lvl-advanced); }
  .scr-item .title{ font-weight:800; font-size:14px; line-height:1.25; }
  .scr-item .desc{ font-size:12px; color:var(--muted); margin-top:2px; }
  .badge{ font-size:11px; font-weight:800; padding:2px 8px; border-radius:999px; background:var(--metric-bg); border:1px solid var(--metric-border); color:var(--muted); white-space:nowrap; margin-top:2px; }
  .scr-item .open-btn{ margin-left:8px; padding:6px 10px; border-radius:10px; border:1px solid var(--border); background:var(--panel); color:var(--text); text-decoration:none; font-weight:700; }
  .scr-item .open-btn:hover{ background:var(--hover); }

  /* === Button glow (added) === */
  .btn, .tool-btn, .theme-toggle, .btmnav .tab {
    --glow-color: var(--focus);
    position: relative;
    transition: box-shadow .15s, transform .06s, background .15s, border-color .15s;
  }
  .btn { --glow-color: var(--accent); }
  .btn:hover, .btn:focus-visible,
  .tool-btn:hover, .tool-btn:focus-visible,
  .theme-toggle:hover, .theme-toggle:focus-visible,
  .btmnav .tab:hover, .btmnav .tab:focus-visible {
    box-shadow:
      0 0 0 2px var(--glow-color),
      0 0 10px var(--glow-color),
      0 0 24px 6px var(--glow-color),
      0 0 40px 12px var(--glow-color);
    z-index: 1;
  }
  .btn:hover::after, .btn:focus-visible::after,
  .tool-btn:hover::after, .tool-btn:focus-visible::after,
  .theme-toggle:hover::after, .theme-toggle:focus-visible::after,
  .btmnav .tab:hover::after, .btmnav .tab:focus-visible::after {
    content: "";
    position: absolute;
    inset: -10px;
    border-radius: inherit;
    background: radial-gradient(60% 60% at 50% 50%, var(--glow-color) 0%, rgba(0,0,0,0) 80%);
    filter: blur(12px);
    z-index: -1;
    pointer-events: none;
    opacity: 0.55;
  }

</style>
</head>
<body>
  <div class="container">
    <!-- Toolbar -->
    <div class="toolbar">
      <div class="ticker-wrap">
        <label for="q">Ticker</label>
        <div class="input-wrap">
          <input id="q" class="ticker-input" type="text" placeholder="AAPL, MSFT‚Ä¶ or BTC" spellcheck="false" autocomplete="off"/>
          <div id="ac" class="ac" role="listbox" aria-label="Suggestions"></div>
        </div>
        <button id="searchBtn" class="btn inline" type="button">Search</button>
      </div>
      <div class="toolsbar" id="toolsBar">
        <button class="tool-btn" id="toolGPTs" aria-label="Open GPTs">üß† <span class="tool-txt">GPTs</span></button>
        <button class="tool-btn" id="toolScreeners" aria-label="Open Screeners">üîé <span class="tool-txt">Screeners</span></button>
        <button class="tool-btn" id="wideBtn" aria-label="Toggle Width">‚ÜîÔ∏é <span class="tool-txt">Wide</span></button>
        <button class="tool-btn" id="maxBtn" aria-label="Maximize">‚§¢ <span class="tool-txt">Max</span></button>
        <button class="tool-btn" id="refreshBtn" aria-label="Refresh">‚ü≥ <span class="tool-txt">Refresh</span></button>
        <button id="themeToggle" class="theme-toggle" type="button">üåô Dark</button>
      </div>
    </div>

    <!-- Info bar -->
    <div id="info" class="info">
      <h3 id="headline" style="margin:0 0 6px 0"></h3>
      <div style="opacity:.9;font-size:14px;line-height:1.6">
        <div id="lastLine">Last: ‚Äî ¬∑ Change: ‚Äî</div>
        <div id="prevCloseLine">Yesterday‚Äôs Close: ‚Äî</div>
        <div id="ivLine">Intrinsic Value: ‚Äî</div>
      </div>
      <img id="infoLogo" class="info-logo" src="/assets/stratus-trader-wide.png" alt="Stratus Trader" />
    </div>

    <!-- Chart card -->
    <div id="chartCard">
      <div class="tf-card" id="tfCard" data-open="true">
        <div class="tf-head" id="tfHead"><span class="carat">‚ñæ</span> <span style="font-style:italic">time frame</span></div>
        <div class="tf-body">
          <div class="control">
            <label for="timeSel">Time</label>
            <select id="timeSel">
              <option value="1d">1 day</option><option value="2d">2 days</option>
              <option value="5d">5 days</option><option value="10d">10 days</option>
              <option value="sep" disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>
              <option value="1mo">1 month</option><option value="2mo">2 months</option>
              <option value="3mo">3 months</option><option value="6mo" selected>6 months</option>
              <option value="ytd">YTD</option><option value="1y">1 year</option>
              <option value="2y">2 years</option><option value="3y">3 years</option>
              <option value="4y">4 years</option><option value="5y">5 years</option>
              <option value="10y">1 decade</option><option value="max">All Data</option>
            </select>
          </div>
          <div class="control">
            <label for="freqSel">Frequency</label>
            <select id="freqSel">
              <option value="1m">1-Minute</option><option value="5m">5-Minute</option>
              <option value="15m">15-Minute</option><option value="60m">Hourly</option>
              <option value="sep" disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>
              <option value="1d" selected>Daily</option><option value="1wk">Weekly</option>
              <option value="1mo">Monthly</option><option value="3mo">Quarterly</option>
              <option value="1y">Yearly</option>
            </select>
          </div>
        </div>
      </div>

      <div class="toggle-row" id="toggles">
        <button class="chip active" data-k="SMA20" type="button">SMA 20</button>
        <button class="chip active" data-k="SMA50" type="button">SMA 50</button>
        <button class="chip active" data-k="SMA200" type="button">SMA 200</button>
        <button class="chip active" data-k="RSI" type="button">RSI</button>
        <button class="chip active" data-k="MACD" type="button">MACD</button>
        <button class="chip active" data-k="VOL" type="button">Volume</button>
        <button class="chip" id="autoFib" data-k="AUTOFIB" type="button">Auto Fib</button>
        <button class="chip active" data-k="ICHI" type="button">Ichimoku</button>
      </div>

      <div id="chart"></div>
    </div>

    <div class="section-sep" aria-hidden="true"><div class="rule"></div></div>
  </div>

  <!-- GPTs Sheet -->
  <div class="sheet" id="sheetGPTs" hidden>
    <div class="sheet-inner">
      <div class="sheet-head">
        <div class="sheet-title">GPTs</div>
        <button class="sheet-close" data-close="sheetGPTs">‚úï</button>
      </div>
      <div class="sheet-body">
        <div class="scr-list" style="margin-bottom:12px">
          <div class="scr-item" data-lvl="Beginner">
            <div style="flex:1;min-width:0">
              <div class="title">9 Prompts for Smarter Investing</div>
              <div class="desc">Bundle of prompts to guide smarter investment analysis.</div>
            </div>
            <div style="display:flex;align-items:center;gap:8px">
              <span class="badge">GPT</span>
              <a class="open-btn" href="https://chatgpt.com/g/g-687b911701a08191aadd69c345a67d17-9-prompts-for-smarter-investing" target="_blank" rel="noopener">Open</a>
            </div>
          </div>
          <div class="scr-item" data-lvl="Beginner">
            <div style="flex:1;min-width:0">
              <div class="title">Stock Predictor Prompt GPT</div>
              <div class="desc">Structured prompt flow for scenario-led stock predictions.</div>
            </div>
            <div style="display:flex;align-items:center;gap:8px">
              <span class="badge">GPT</span>
              <a class="open-btn" href="https://chatgpt.com/g/g-686c5fc3dd948191a0ff9c14cecda1b4-stock-predictor-prompt-gpt" target="_blank" rel="noopener">Open</a>
            </div>
          </div>
          <div class="scr-item" data-lvl="Beginner">
            <div style="flex:1;min-width:0">
              <div class="title">High Yield Dividend Sniper</div>
              <div class="desc">Quickly target high-yield dividend candidates.</div>
            </div>
            <div style="display:flex;align-items:center;gap:8px">
              <span class="badge">GPT</span>
              <a class="open-btn" href="https://chatgpt.com/g/g-6878fe277c5c819180211289d9e16148-high-yield-dividend-sniper" target="_blank" rel="noopener">Open</a>
            </div>
          </div>
        </div>
        <div>
          <textarea id="gptInput" rows="4" placeholder="Ask a question about the current ticker‚Ä¶" style="width:100%;background:var(--field-bg);color:var(--field-text);border:1px solid var(--border);border-radius:10px;padding:10px"></textarea>
          <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
            <button class="btn" id="askGPT">Ask</button>
            <div style="font-size:12px;color:var(--muted)">Uses the visible chart context when possible.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Screeners Sheet -->
  <div class="sheet" id="sheetScreeners" hidden>
    <div class="sheet-inner">
      <div class="sheet-head">
        <div class="sheet-title">Screeners</div>
        <button class="sheet-close" data-close="sheetScreeners">‚úï</button>
      </div>
      <div class="sheet-body">
        <div class="scr-list" id="scrList"></div>
      </div>
    </div>
  </div>

  <nav class="btmnav" id="btmNav" role="navigation" aria-label="Bottom Navigation">
    <button data-tab="home" class="tab active" aria-label="Home">üè†<span>Home</span></button>
    <button data-tab="screeners" class="tab" aria-label="Screeners">üîé<span>Screeners</span></button>
    <button data-tab="gpts" class="tab" aria-label="GPTs">üß†<span>GPTs</span></button>
    <button data-tab="settings" class="tab" aria-label="Settings">‚öôÔ∏è<span>Settings</span></button>
  </nav>

  <!-- Single app script -->
  <script>
(() => {
  const q = s => document.querySelector(s);

  /* ---------- Aliases & crypto handling ---------- */
  const SYMBOL_ALIASES = Object.freeze({
    BTC:'BTC-USD', ETH:'ETH-USD', SOL:'SOL-USD', DOGE:'DOGE-USD',
    XRP:'XRP-USD', ADA:'ADA-USD', LTC:'LTC-USD', BCH:'BCH-USD',
    BNB:'BNB-USD', SPX:'^GSPC'
  });
  const normalizeTicker = t => SYMBOL_ALIASES[String(t||'').trim().toUpperCase()] || String(t||'').trim().toUpperCase();
  const isCrypto = t => /-USD$/.test(t);

  /* ---------- Guard ---------- */
  for (const sel of ['#q', '#searchBtn', '#chart']) {
    if (!document.querySelector(sel)) {
      const msg = document.createElement('div');
      msg.style.cssText='margin:16px;padding:12px;border:1px solid #ef4444;border-radius:10px;color:#ef4444;background:#1b0f0f;font-weight:800';
      msg.textContent='‚ö†Ô∏è This is not the Stock Analyzer page (missing core elements).';
      document.body.prepend(msg);
      return;
    }
  }

  /* ---------- Elements ---------- */
  const els = {
    input:q('#q'), list:q('#ac'), searchBtn:q('#searchBtn'),
    headline:q('#headline'), lastLine:q('#lastLine'), prevCloseLine:q('#prevCloseLine'), ivLine:q('#ivLine'),
    chartCard:q('#chartCard'), chart:q('#chart'),
    timeSel:q('#timeSel'), freqSel:q('#freqSel'), toggles:q('#toggles'),
    themeToggle:q('#themeToggle'), autoFib:q('#autoFib'),
    refreshBtn:q('#refreshBtn'), maxBtn:q('#maxBtn'), wideBtn:q('#wideBtn'),
    tfCard:q('#tfCard'), tfHead:q('#tfHead')
  };

  /* ---------- State ---------- */
  let CURRENT = { ticker:null, company:"", prevClose:null };
  let FUNDAMENTALS = {};
  let traceMap = {};
  let PRICE_TIMER = null;
  let FIB_LOCK = false;
  const fibActive = () => els.autoFib?.classList?.contains('active');

  /* ---------- Utils ---------- */
  const fmt = n => (Number.isFinite(n) ? n.toFixed(2) : '‚Äî');
  const css = v => getComputedStyle(document.documentElement).getPropertyValue(v).trim();
  const escapeHTML = s => s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
  const debounce = (fn,ms)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; };
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  const toET = (d=new Date()) => new Date(d.toLocaleString('en-US',{timeZone:'America/New_York'}));
  function toEastern(date){ return new Date(date.toLocaleString('en-US',{timeZone:'America/New_York'})); }
  function formatEasternISO(date){ const d=toEastern(date); return new Date(Date.UTC(d.getFullYear(),d.getMonth(),d.getDate(),d.getHours(),d.getMinutes(),d.getSeconds(),d.getMilliseconds())).toISOString(); }
  const isMarketOpenNow = () => { const d=toET(); const wd=d.getDay(); if(wd===0||wd===6) return false; const m=d.getHours()*60+d.getMinutes(); return m>=(9*60+30)&&m<(16*60); };
  async function waitForPlotly(timeoutMs=12000){
    const start=Date.now();
    while(!(window.Plotly && window.Plotly.newPlot)){
      if(Date.now()-start>timeoutMs) throw new Error('Plotly failed to load');
      await sleep(25);
    }
  }

  /* ---------- Theme ---------- */
  const THEMES = {
    dark:{'--bg':'#0f1115','--panel':'#151923','--text':'#e5e7eb','--muted':'#9ca3af','--accent':'#22c55e','--focus':'#3b82f6','--border':'#23283a','--hover':'#161a25','--metric-bg':'#1a1f2e','--metric-border':'#2a2f3e'},
    light:{'--bg':'#f8fafc','--panel':'#fff','--text':'#222','--muted':'#64748b','--accent':'#22c55e','--focus':'#3b82f6','--border':'#e2e8f0','--hover':'#f1f5f9','--metric-bg':'#f1f5f9','--metric-border':'#e2e8f0'}
  };
  function applyChartTheme(){
    if(!els.chart||!window.Plotly) return;
    const panelBg=getComputedStyle(els.chartCard).backgroundColor;
    const txt=css('--text')||'#e5e7eb';
    const grid=css('--grid')||'#222837';
    try{
      Plotly.relayout(els.chart,{
        paper_bgcolor:panelBg, plot_bgcolor:panelBg,
        'xaxis.gridcolor':grid, 'yaxis.gridcolor':grid, 'yaxis2.gridcolor':grid, 'yaxis3.gridcolor':grid, 'yaxis4.gridcolor':grid,
        'xaxis.tickfont.color':txt, 'yaxis.tickfont.color':txt, 'yaxis2.tickfont.color':txt, 'yaxis3.tickfont.color':txt, 'yaxis4.tickfont.color':txt
      });
    }catch{}
  }
  function setTheme(t){
    Object.entries(THEMES[t]).forEach(([k,v])=>document.documentElement.style.setProperty(k,v));
    document.body.classList.toggle('light', t==='light');
    els.themeToggle.textContent = t==='dark' ? '‚òÄÔ∏è Light' : 'üåô Dark';
    els.themeToggle.classList.toggle('active', t==='dark');
    localStorage.setItem('theme',t);
    requestAnimationFrame(()=>{ applyChartTheme(); if(CURRENT.ticker) go(CURRENT.ticker, CURRENT.company); });
  }
  const getTheme = () => localStorage.getItem('theme')||'dark';
  els.themeToggle.addEventListener('click',()=> setTheme(getTheme()==='dark'?'light':'dark'));
  setTheme(getTheme());

  /* ---------- Collapsible ---------- */
  els.tfHead.addEventListener('click',()=>{
    const open = els.tfCard.getAttribute('data-open') === 'true';
    els.tfCard.setAttribute('data-open', open ? 'false' : 'true');
  });

  /* ---------- Fundamentals ---------- */
  async function getFundamentals(ticker){
    if(isCrypto(ticker)) return {};
    try{
      const r = await fetch(`/api/summary?ticker=${encodeURIComponent(ticker)}&modules=defaultKeyStatistics,financialData,earningsTrend`, { cache:'no-store' });
      if(!r.ok) throw new Error('summary '+r.status);
      const j = await r.json();
      const res = j?.quoteSummary?.result?.[0] || {};
      const ek=res.defaultKeyStatistics||{}, fd=res.financialData||{}, et=res.earningsTrend||{};
      const eps = (ek.trailingEps?.raw ?? fd.epsTrailingTwelveMonths?.raw);
      let growth=null;
      const trends=Array.isArray(et.trend)?et.trend:[];
      const fiveY=trends.find(t=>(t.period||'').toLowerCase().includes('5y'));
      if(fiveY?.growth?.raw!=null) growth=fiveY.growth.raw; else if(fd.growth?.raw!=null) growth=fd.growth.raw;
      const ivGraham = (Number.isFinite(eps) && Number.isFinite(growth)) ? eps * (8.5 + 2 * (growth*100)) : null;
      return { eps: +eps || null, growth: +growth || null, ivGraham };
    }catch{ return {}; }
  }

  /* ---------- Indicators ---------- */
  function SMA(vals, w) {
    // Expanding window: for first w-1 points, use average of all available so far
    const out = new Array(vals.length).fill(null);
    let sum = 0, count = 0;
    for (let i = 0; i < vals.length; i++) {
      const v = vals[i];
      if (Number.isFinite(v)) { sum += v; count++; }
      if (i < w - 1) {
        out[i] = count > 0 ? sum / count : null; // expanding window
      } else {
        if (i >= w) {
          const old = vals[i - w];
          if (Number.isFinite(old)) { sum -= old; count--; }
        }
        out[i] = count > 0 ? sum / w : null;
      }
    }
    return out;
  }
  function EMA(vals,span){ const out=new Array(vals.length).fill(null),k=2/(span+1); let ema=null;
    for(let i=0;i<vals.length;i++){ const v=vals[i]; if(!Number.isFinite(v)){ out[i]=(i>0?out[i-1]:null); continue; } ema=(ema==null)?v:v*k+ema*(1-k); out[i]=ema; } return out; }
  function RSI(values, period=14){ const rsi=new Array(values.length).fill(null); if(values.length<=period) return rsi;
    let gain=0,loss=0; for(let i=1;i<=period;i++){ const d=values[i]-values[i-1]; if(d>0) gain+=d; else loss-=d; }
    gain/=period; loss/=period; rsi[period]=100-100/(1+(gain/(loss||1e-10)));
    for(let i=period+1;i<values.length;i++){ const d=values[i]-values[i-1];
      if(d>0){ gain=(gain*(period-1)+d)/period; loss=(loss*(period-1))/period; }
      else { gain=(gain*(period-1))/period; loss=(loss*(period-1)-d)/period; }
      rsi[i]=100-100/(1+(gain/(loss||1e-10)));
    } return rsi;
  }
  function MACD(closes,f=12,s=26,sig=9){ const ef=EMA(closes,f), es=EMA(closes,s);
    const macd=closes.map((_,i)=> (ef[i]!=null&&es[i]!=null)? ef[i]-es[i] : null);
    const signal=EMA(macd.map(x=>x==null?null:x),sig);
    const hist=macd.map((m,i)=> (m!=null&&signal[i]!=null)? (m-signal[i]) : null);
    return {macd,signal,hist};
  }

  /* ---------- Ichimoku helpers ---------- */
  function rollingHigh(arr, window){ const out=new Array(arr.length).fill(null);
    for(let i=0;i<arr.length;i++){ if(i<window-1) continue; let hi=-Infinity; for(let j=i-window+1;j<=i;j++) if(Number.isFinite(arr[j])) hi=Math.max(hi,arr[j]); out[i]=Number.isFinite(hi)?hi:null; } return out; }
  function rollingLow(arr, window){ const out=new Array(arr.length).fill(null);
    for(let i=0;i<arr.length;i++){ if(i<window-1) continue; let lo=Infinity; for(let j=i-window+1;j<=i;j++) if(Number.isFinite(arr[j])) lo=Math.min(lo,arr[j]); out[i]=Number.isFinite(lo)?lo:null; } return out; }
  function arrShiftFwd(arr,k,n){ const out=new Array(n).fill(null); for(let i=0;i<n;i++) if(i+k<n) out[i+k]=arr[i]; return out; }
  function arrShiftBack(arr,k,n){ const out=new Array(n).fill(null); for(let i=0;i<n;i++) if(i-k>=0) out[i-k]=arr[i]; return out; }
  function calcIchimoku(rows){
    const n=rows.length, high=rows.map(r=>r.h), low=rows.map(r=>r.l), close=rows.map(r=>r.c);
    const convHi=rollingHigh(high,9),  convLo=rollingLow(low,9);
    const kijHi =rollingHigh(high,26), kijLo=rollingLow(low,26);
    const senBHi=rollingHigh(high,52),  senBLo=rollingLow(low,52);
    const tenkan=convHi.map((h,i)=> (h!=null&&convLo[i]!=null)?(h+convLo[i])/2:null);
    const kijun =kijHi .map((h,i)=> (h!=null&&kijLo[i]!=null)?(h+kijLo[i])/2:null);
    const senA0=tenkan.map((t,i)=> (t!=null&&kijun[i]!=null)?(t+kijun[i])/2:null);
    const senB0=senBHi.map((h,i)=> (h!=null&&senBLo[i]!=null)?(h+senBLo[i])/2:null);
    const shift=26, spanA=arrShiftFwd(senA0,shift,n), spanB=arrShiftFwd(senB0,shift,n), chikou=arrShiftBack(close,shift,n);
    return { tenkan, kijun, spanA, spanB, chikou };
  }
  function segmentCloud(a,b){
    const n=a.length, gLow=Array(n).fill(null), gUp=Array(n).fill(null), rLow=Array(n).fill(null), rUp=Array(n).fill(null);
    for(let i=0;i<n;i++){ const A=a[i], B=b[i]; if(!Number.isFinite(A)||!Number.isFinite(B)) continue; if(A>=B){ gLow[i]=B; gUp[i]=A; } else { rLow[i]=A; rUp[i]=B; } }
    return { gLow, gUp, rLow, rUp };
  }
  function fillEdges(arr){
    const out = arr.slice();
    let last = null;
    for(let i=0;i<out.length;i++){ if(Number.isFinite(out[i])) last=out[i]; else if(last!=null) out[i]=last; }
    const fi = out.findIndex(v=>Number.isFinite(v));
    if(fi>0){ for(let i=0;i<fi;i++) out[i]=out[fi]; }
    let li=-1; for(let i=out.length-1;i>=0;i--){ if(Number.isFinite(out[i])){ li=i; break; } }
    if(li>=0){ for(let i=li+1;i<out.length;i++) out[i]=out[li]; }
    return out;
  }
  function exaggerateCloud(spanA, spanB, mag=1.8, loClip=-Infinity, hiClip=Infinity){
    if(!(mag>1)) return {spanA,spanB};
    const A=spanA.slice(), B=spanB.slice();
    for(let i=0;i<A.length;i++){
      const a=A[i], b=B[i]; if(!Number.isFinite(a)||!Number.isFinite(b)) continue;
      const mid=(a+b)/2, half=(a-b)/2;
      A[i]=Math.min(Math.max(mid+half*mag, loClip), hiClip);
      B[i]=Math.min(Math.max(mid-half*mag, loClip), hiClip);
    }
    return {spanA:A, spanB:B};
  }

  /* ---------- SMA helper ---------- */
  function alignAndExtendSMA(smaAll, visibleLen, startIdx){
    let arr = smaAll.slice(Math.max(0,startIdx), Math.max(0,startIdx)+visibleLen);
    while (arr.length < visibleLen) arr.unshift(null);
    const firstIdx = arr.findIndex(v => Number.isFinite(v));
    if (firstIdx > 0){ const firstVal=arr[firstIdx]; for(let i=0;i<firstIdx;i++) arr[i]=firstVal; }
    for (let i=1;i<arr.length;i++) if (arr[i]==null && Number.isFinite(arr[i-1])) arr[i]=arr[i-1];
    return arr;
  }

  /* ---------- Auto-Fib ---------- */
  function getAxisState(){
    const L = els.chart && (els.chart._fullLayout || els.chart.layout);
    const g = ax => ({ range:(L?.[ax]?.range)?[...L[ax].range]:null, autorange:L?.[ax]?.autorange!==false });
    return { x:g('xaxis'), y:g('yaxis'), y2:g('yaxis2'), y3:g('yaxis3'), y4:g('yaxis4') };
  }
  function relayoutPreserve(payload){
    const S=getAxisState(); const keep=(axKey,s)=>{ if(!s) return {}; const out={}; if(s.range){out[`${axKey}.range`]=s.range; out[`${axKey}.autorange`]=false;} else if(s.autorange){out[`${axKey}.autorange`]=true;} return out; };
    return Plotly.relayout(els.chart,{...payload,...keep('xaxis',S.x),...keep('yaxis',S.y),...keep('yaxis2',S.y2),...keep('yaxis3',S.y3),...keep('yaxis4',S.y4)});
  }
  const getCandleTrace = () => { const d=els.chart?.data||[]; const i=d.findIndex(t=>t&&t.type==='candlestick'); return i>=0?d[i]:null; };
  const addOrUpdateAutoFibTraces = debounce(async () => {
    if(!fibActive()||!els.chart||FIB_LOCK) return;
    const c=getCandleTrace(); if(!c) return;
    const cx=c.x, ch=c.high, cl=c.low; if(!cx?.length) return;
    const L=els.chart._fullLayout||els.chart.layout||{}, xa=L.xaxis||{};
    const x0=(Array.isArray(xa.range)&&xa.autorange===false)?xa.range[0]:cx[0];
    const x1=(Array.isArray(xa.range)&&xa.autorange===false)?xa.range[1]:cx[cx.length-1];
    const i0=Math.max(0, cx.findIndex(d=>d>=x0)); let i1=cx.findIndex(d=>d>x1); if(i1===-1) i1=cx.length; if(i1<=i0) return;
    let hi=-Infinity, lo=Infinity; for(let i=i0;i<i1;i++){ if(Number.isFinite(ch[i])) hi=Math.max(hi,ch[i]); if(Number.isFinite(cl[i])) lo=Math.min(lo,cl[i]); }
    if(!Number.isFinite(hi)||!Number.isFinite(lo)||hi===lo) return;
    const lvls=[1,.786,.618,.5,.382,.236,0], color=css('--c-rsi')||'#8b5cf6', prices=lvls.map(p=>hi-(hi-lo)*p);
    const shapes=prices.map(y=>({type:'line',xref:'x',yref:'y',x0,x1,y0:y,y1:y,line:{color,width:1.25,dash:'dot'},layer:'above',opacity:.95}));
    const anns=prices.map((y,i)=>({x:x1,y,xref:'x',yref:'y',xanchor:'right',yanchor:'middle',text:`${(lvls[i]*100).toFixed(1)}%  ${y.toFixed(2)}`,showarrow:false,font:{size:11,color}}));
    try { FIB_LOCK = true; await relayoutPreserve({ shapes, annotations: anns }); } finally { FIB_LOCK = false; }
  }, 30);
  const clearAutoFib = () => { if(!els.chart) return; try{ FIB_LOCK=true; relayoutPreserve({shapes:[],annotations:[]}); } finally { FIB_LOCK=false; } };

  // --- Restore autocomplete and search logic ---
  let LOCAL_SYMBOLS = [];
  let suggestions = [];
  let activeIndex = -1;

  async function loadSymbolsFromCSV() {
    if (LOCAL_SYMBOLS.length) return LOCAL_SYMBOLS;
    try {
      const r = await fetch('/assets/us_symbols.csv', { cache:'no-store' });
      if (!r.ok) throw new Error('symbols ' + r.status);
      const text = await r.text();
      const lines = text.split(/\r?\n/).filter(Boolean);
      const delim = ',';
      let start = 0;
      const first = lines[0].split(delim).map(s => s.trim().toLowerCase());
      if (first[0] && /(symbol|ticker)/.test(first[0])) start = 1;
      const out = [];
      for (let i = start; i < lines.length; i++) {
        const line = lines[i];
        const cut = line.indexOf(delim);
        if (cut === -1) continue;
        const sym = line.slice(0, cut).trim().toUpperCase();
        const name = line.slice(cut + 1).trim();
        if (/^[A-Z0-9.^$\-]{1,12}$/.test(sym)) out.push({ symbol: sym, name });
      }
      LOCAL_SYMBOLS = out;
    } catch {
      LOCAL_SYMBOLS = [
        {symbol:'AAPL',name:'Apple Inc'},
        {symbol:'MSFT',name:'Microsoft Corp'},
        {symbol:'TSLA',name:'Tesla Inc'},
        {symbol:'NVDA',name:'NVIDIA Corp'},
        {symbol:'AMZN',name:'Amazon.com Inc'}
      ];
    }
    LOCAL_SYMBOLS.sort((a,b)=>a.symbol.localeCompare(b.symbol));
    return LOCAL_SYMBOLS;
  }
  function searchLocalSymbols(q) {
    if (!q) return [];
    const out = [];
    const qLower = q.toLowerCase();
    for (const r of LOCAL_SYMBOLS) {
      if (r.symbol.startsWith(q)) { out.push(r); if (out.length >= 12) break; }
    }
    if (out.length < 12) {
      const seen = new Set(out.map(r => r.symbol));
      for (const r of LOCAL_SYMBOLS) {
        if (seen.has(r.symbol)) continue;
        if (r.symbol.includes(q) || (r.name && r.name.toLowerCase().includes(qLower))) {
          out.push(r);
          if (out.length >= 12) break;
        }
      }
    }
    return out;
  }
  function renderAC() {
    els.list.innerHTML = '';
    if (!suggestions.length) { els.list.classList.remove('show'); return; }
    suggestions.forEach((it, i) => {
      const div = document.createElement('div');
      div.className = 'ac-item' + (i === activeIndex ? ' active' : '');
      div.dataset.i = i;
      div.innerHTML = `<div class="ticker">${it.symbol}</div><div class="company">${escapeHTML(it.name || '')}</div>`;
      div.addEventListener('mousedown', e => { e.preventDefault(); pick(i); });
      els.list.appendChild(div);
    });
    els.list.classList.add('show');
  }
  const hideAC = () => { els.list.classList.remove('show'); activeIndex = -1; };
  function pick(i) {
    const it = suggestions[i];
    if (!it) return;
    const sym = normalizeTicker(it.symbol);
    els.input.value = sym;
    hideAC();
    onSearch(sym, it.name || '');
  }
  function doSearchFromInput() {
    let t = normalizeTicker(els.input.value.trim().toUpperCase());
    hideAC();
    if (!/^[A-Z0-9.^$\-]{1,12}$/.test(t)) { return; }
    const found = LOCAL_SYMBOLS.find(r => r.symbol === t) || LOCAL_SYMBOLS.find(r => (r.name||'').toUpperCase() === t);
    const comp = found?.name || '';
    onSearch(t, comp);
  }
  els.input.addEventListener('input', debounce(async () => {
    if (!LOCAL_SYMBOLS.length) await loadSymbolsFromCSV();
    const val = els.input.value;
    if (val !== val.toUpperCase()) {
      const st = els.input.selectionStart, en = els.input.selectionEnd;
      els.input.value = val.toUpperCase();
      els.input.setSelectionRange(st, en);
    }
    const qv = els.input.value.trim().toUpperCase();
    if (!qv) { hideAC(); return; }
    suggestions = searchLocalSymbols(qv);
    activeIndex = -1;
    renderAC();
  }, 120));
  els.input.addEventListener('keydown', e => {
    if (els.list.classList.contains('show')) {
      if (e.key === 'ArrowDown') { e.preventDefault(); activeIndex = (activeIndex + 1) % suggestions.length; renderAC(); return; }
      if (e.key === 'ArrowUp')   { e.preventDefault(); activeIndex = (activeIndex - 1 + suggestions.length) % suggestions.length; renderAC(); return; }
      if (e.key === 'Enter' || e.key === 'Tab') { if (activeIndex >= 0) { e.preventDefault(); pick(activeIndex); return; } }
      if (e.key === 'Escape') { hideAC(); return; }
    }
    if (e.key === 'Enter') { e.preventDefault(); hideAC(); doSearchFromInput(); }
  });
  document.addEventListener('click', e => { if (!e.target.closest('.ticker-wrap')) hideAC(); });
  els.input.addEventListener('blur', () => setTimeout(hideAC, 100));
  window.addEventListener('scroll', hideAC, { passive: true });
  els.searchBtn.addEventListener('click', () => { hideAC(); doSearchFromInput(); });
  loadSymbolsFromCSV().catch(()=>{});
  /* ---------- Fetch & shape ---------- */
  function normalizePair(time,freq){
    const minFor={ '1m':'1d','5m':'5d','15m':'10d','60m':'1mo' };
    const order=['1d','2d','5d','10d','1mo','2mo','3mo','6mo','ytd','1y','2y','3y','4y','5y','10y','max'];
    const idx=v=>Math.max(0,order.indexOf(v));
    if(['1m','5m','15m','60m'].includes(freq)){ const minRange=minFor[freq]; if(idx(time)<idx(minRange)) time=minRange; return { range:time, interval: freq==='60m' ? '60m' : freq }; }
    // Yahoo doesn't actually serve "1y" bars; we‚Äôll fetch monthly and aggregate to yearly
    const map={'1d':'1d','1wk':'1wk','1mo':'1mo','3mo':'3mo','1y':'1mo'};
    return { range:time, interval: map[freq]||'1d' };
  }
  function historyRangeFor(freq,time){
    if(freq==='1m') return '7d';
    if(freq==='5m'||freq==='15m'||freq==='60m') return '2mo';
    const map={'1d':'1y','2d':'1y','5d':'1y','10d':'1y','1mo':'1y','2mo':'2y','3mo':'2y','6mo':'2y','ytd':'2y','1y':'3y','2y':'5y','3y':'5y','4y':'10y','5y':'10y','10y':'max','max':'max'};
    return map[time]||'3y';
  }
  function aggregateToYear(rows){
    if(!rows.length) return rows;
    const byY = new Map();
    for(const r of rows){
      const y = toET(r.date).getFullYear();
      let b = byY.get(y);
      if(!b) byY.set(y, b={ o:r.o, h:r.h, l:r.l, c:r.c, v:r.v, date: new Date(y,0,1) });
      b.h = Math.max(b.h, r.h);
      b.l = Math.min(b.l, r.l);
      b.c = r.c;
      b.v += r.v;
    }
    return Array.from(byY.entries()).sort((a,b)=>a[0]-b[0]).map(([,v])=>v);
  }
  async function fetchFullHistory(ticker,time,freq){ const range=historyRangeFor(freq,time); return await fetchChart(ticker,range,freq); }
  async function fetchChart(ticker,time,freq){
    const widen={'1m':['1d','2d','5d'],'5m':['5d','10d','1mo','2mo'],'15m':['10d','1mo','2mo'],'60m':['1mo','2mo','3mo']};
    const tryRanges=['1m','5m','15m','60m'].includes(freq)?[...new Set([time, ...(widen[freq]||[])])]:[time];
    let lastErr; for(const candidate of tryRanges){
      try{
        const {range,interval}=normalizePair(candidate,freq);
        const r=await fetch(`/api/chart?ticker=${encodeURIComponent(ticker)}&range=${range}&interval=${interval}`,{cache:'no-store'}); if(!r.ok) throw new Error(`Proxy ${r.status}`);
        const j=await r.json(); const res=j?.chart?.result?.[0]; if(!res) throw new Error('No result');
        const q=res.indicators?.quote?.[0]||{}; const ts=res.timestamp||[];
        const rows=[];
        for(let i=0;i<ts.length;i++){
          const o=q.open?.[i], h=q.high?.[i], l=q.low?.[i];
          const adj=res.indicators?.adjclose?.[0]?.adjclose;
          const cRaw=(adj && adj[i]!=null) ? adj[i] : q.close?.[i];
          const c=Number.isFinite(+cRaw)?+cRaw:null;
          const v=Number.isFinite(q.volume?.[i])?+q.volume[i]:0;
          if([o,h,l,c].every(Number.isFinite)) rows.push({date:new Date(ts[i]*1000),o:+o,h:+h,l:+l,c:+c,v});
        }
        return rows;
      }catch(e){ lastErr=e; }
    }
    throw lastErr||new Error('Fetch failed');
  }
  function getVisibleData(fullData, range, freq){
    const intraday=['1m','5m','15m','60m'].includes(freq);
    const m = intraday ? /^(\d+)d$/.exec(range) : null;
    if (m) {
      const want=Math.max(1,+m[1]); let firstIdx=0, sessionsSeen=0, curKey=null;
      for(let i=fullData.length-1;i>=0;i--){
        const et=toET(fullData[i].date);
        const key=et.getFullYear()+'-'+(et.getMonth()+1)+'-'+et.getDate();
        if(key!==curKey){ sessionsSeen++; curKey=key; if(sessionsSeen>want){ firstIdx=i+1; break; } }
      }
      return fullData.slice(firstIdx);
    }
    if (range==='ytd'){
      const now=new Date(); const jan1=new Date(now.getFullYear(),0,1);
      return fullData.filter(it => toET(it.date) >= toET(jan1));
    }
    const daysMap={'1d':1,'2d':2,'5d':5,'10d':10,'1mo':31,'2mo':62,'3mo':93,'6mo':182,'1y':365,'2y':730,'3y':1095,'4y':1460,'5y':1825,'10y':3650,'max':36500};
    const days=daysMap[range] ?? 365; const cutoff=new Date(Date.now()-days*864e5);
    return fullData.filter(it => toET(it.date) >= toET(cutoff));
  }
  function prevDailyCloseFromIntraday(fullRows){
    if(!fullRows?.length) return null;
    const lastDayStr=toEastern(fullRows.at(-1).date).toDateString();
    for(let i=fullRows.length-2;i>=0;i--){ const d=toEastern(fullRows[i].date).toDateString(); if(d!==lastDayStr) return fullRows[i].c ?? null; }
    return null;
  }

  /* ---------- Price ticker ---------- */
  async function fetchLastPriceLight(ticker){
    try{
      const r = await fetch(`/api/quote?ticker=${encodeURIComponent(ticker)}`, { cache:'no-store' });
      if (r.ok) {
        const j=await r.json();
        const p=j?.price ?? j?.quoteResponse?.result?.[0]?.regularMarketPrice;
        if(Number.isFinite(+p)) return +p;
      }
    }catch{}
    try{
      const r = await fetch(`/api/chart?ticker=${encodeURIComponent(ticker)}&range=1d&interval=1m`, { cache:'no-store' });
      if(!r.ok) throw 0;
      const j=await r.json();
      const res=j?.chart?.result?.[0];
      const q=res?.indicators?.quote?.[0];
      const adj=res?.indicators?.adjclose?.[0]?.adjclose;
      const close=(adj && adj.at(-1)!=null) ? adj.at(-1) : q?.close?.at(-1);
      return Number.isFinite(+close) ? +close : null;
    }catch{ return null; }
  }
  async function tickPriceOnce(){
    if(!CURRENT?.ticker) return;
    const last=await fetchLastPriceLight(CURRENT.ticker);
    if(!Number.isFinite(last)) return;
    const prev=CURRENT.prevClose ?? null;
    const dayChg=(prev!=null?last-prev:null);
    const dayPct=(prev!=null && prev!==0)?(dayChg/prev)*100:null;
    const upClr=css('--c-up'), dnClr=css('--c-down');
    const chgClr=dayChg>0?upClr:dayChg<0?dnClr:'#cbd5e1';
    const signChg=dayChg>0?'+':dayChg<0?'-':'';
    const signPct=dayPct>0?'+':dayPct<0?'-':'';
    els.lastLine.innerHTML = `Last: <b>$${fmt(last)}</b> ¬∑ <span style="color:${chgClr};font-weight:800">Change: ${dayChg==null? '‚Äî' : `${signChg}$${fmt(Math.abs(dayChg))} <span style='opacity:.85'>(${signPct}${fmt(Math.abs(dayPct))}%)</span>`}</span>`;
  }
  function startPriceTicker(){
    stopPriceTicker();
    const base=['1m','5m','15m','60m'].includes(els.freqSel.value) ? 30000 : 60000;
    const interval=isMarketOpenNow()?base:180000;
    const run=()=>{ if(!document.hidden) tickPriceOnce(); };
    run(); PRICE_TIMER=setInterval(run,interval);
  }
  const stopPriceTicker=()=>{ if(PRICE_TIMER){ clearInterval(PRICE_TIMER); PRICE_TIMER=null; } };
  document.addEventListener('visibilitychange',()=>{ if(PRICE_TIMER && document.hidden) return; if(!PRICE_TIMER && !document.hidden && CURRENT.ticker) startPriceTicker(); });

  /* ---------- Main flow ---------- */
  async function onSearch(ticker, company){
    if(!FUNDAMENTALS[ticker]){ try{ FUNDAMENTALS[ticker]=await getFundamentals(ticker); }catch{ FUNDAMENTALS[ticker]={}; } }
    await go(ticker, company);
  }
  // --- Fit y-axis strictly to visible candlestick highs/lows ------------------
  const fitPriceAxisToCandlesStrict = async () => {
    if (!els.chart) return;
    const d = els.chart.data || [];
    const c = d.find(t => t && t.type === 'candlestick');
    if (!c || !c.x || !c.high || !c.low || !c.x.length) return;

    const toMs = (v) => new Date(v).getTime();

    // Determine current visible x window
    const L  = els.chart._fullLayout || els.chart.layout || {};
    const xa = L.xaxis || {};
    let x0ms, x1ms;
    if (Array.isArray(xa.range) && xa.autorange === false) {
      x0ms = toMs(xa.range[0]);
      x1ms = toMs(xa.range[1]);
    } else {
      x0ms = toMs(c.x[0]);
      x1ms = toMs(c.x[c.x.length - 1]);
    }

    // Visible indices
    const cxms = c.x.map(toMs);
    let i0 = 0;
    while (i0 < cxms.length && cxms[i0] < x0ms) i0++;
    let i1 = cxms.length - 1;
    while (i1 > i0 && cxms[i1] > x1ms) i1--;

    if (i1 <= i0) return;

    // Compute hi/lo strictly from visible candles
    let hi = -Infinity, lo = Infinity;
    for (let i = i0; i <= i1; i++) {
      const h = c.high[i], l = c.low[i];
      if (Number.isFinite(h)) hi = Math.max(hi, h);
      if (Number.isFinite(l)) lo = Math.min(lo, l);
    }
    if (!Number.isFinite(hi) || !Number.isFinite(lo)) return;
    if (hi === lo) { hi += 1; lo -= 1; }

    const pad = Math.max( (hi - lo) * 0.08, 0.5 ); // padding
    const payload = {
      'yaxis.autorange': false,
      'yaxis.rangemode': 'normal',
      'yaxis.range': [lo - pad, hi + pad]
    };
    try {
      if (typeof relayoutPreserve === 'function') {
        await relayoutPreserve(payload);
      } else {
        await Plotly.relayout(els.chart, payload);
      }
    } catch (_) {}
  };

  
  async function go(ticker, company){
    CURRENT={...CURRENT,ticker,company};
    els.headline.textContent=`${ticker}${company?' ‚Äî '+company:''}`;
    els.lastLine.textContent = 'Loading...';
    els.prevCloseLine.textContent = '';
    els.ivLine.textContent = '';
    let fullRows = [];
    try {
      fullRows = await fetchFullHistory(ticker, els.timeSel.value, els.freqSel.value);
    } catch { fullRows = []; }
    if (!fullRows.length) {
      els.chart.innerHTML = '<div style="color:#ef4444;font-weight:800;padding:24px;text-align:center">No data available for this symbol.</div>';
      els.lastLine.textContent = '‚Äî';
      els.prevCloseLine.textContent = '‚Äî';
      els.ivLine.textContent = '‚Äî';
      return;
    }
    // Info bar update (already patched)
    const lastRow = fullRows.at(-1);
    const prevClose = prevDailyCloseFromIntraday(fullRows);
    const lastPrice = lastRow?.c ?? null;
    const lastDate = lastRow?.date ? toET(lastRow.date) : null;
    let dayChg = null, dayPct = null, chgClr = '#cbd5e1', signChg = '', signPct = '';
    if (prevClose != null && lastPrice != null) {
      dayChg = lastPrice - prevClose;
      dayPct = prevClose !== 0 ? (dayChg / prevClose) * 100 : null;
      chgClr = dayChg > 0 ? css('--c-up')||'#16a34a' : dayChg < 0 ? css('--c-down')||'#dc2626' : '#cbd5e1';
      signChg = dayChg > 0 ? '+' : dayChg < 0 ? '-' : '';
      signPct = dayPct > 0 ? '+' : dayPct < 0 ? '-' : '';
    }
    els.lastLine.innerHTML = `Last: <b>$${fmt(lastPrice)}</b> ¬∑ <span style="color:${chgClr};font-weight:800">Change: ${dayChg==null? '‚Äî' : `${signChg}$${fmt(Math.abs(dayChg))} <span style='opacity:.85'>(${signPct}${fmt(Math.abs(dayPct))}%)</span>`}</span>`;
    els.prevCloseLine.innerHTML = `Yesterday‚Äôs Close: ${prevClose != null ? '$'+fmt(prevClose) : '‚Äî'}`;
    els.ivLine.innerHTML = `Last checked: ${lastDate ? lastDate.toLocaleString() : '‚Äî'}`;
    // Chart rendering
    const visibleRows = getVisibleData(fullRows, els.timeSel.value, els.freqSel.value);
    LAST_VISIBLE_ROWS = visibleRows;
    if (!visibleRows.length) {
      els.chart.innerHTML = '<div style="color:#ef4444;font-weight:800;padding:24px;text-align:center">No visible data for this range.</div>';
      return;
    }
    const x = visibleRows.map(r=>r.date);
    const close = visibleRows.map(r=>r.c);
    const open = visibleRows.map(r=>r.o);
    const high = visibleRows.map(r=>r.h);
    const low = visibleRows.map(r=>r.l);
    // Calculate overlays
    const sma20 = SMA(close, 20);
    const sma50 = SMA(close, 50);
    const sma200 = SMA(close, 200);
    // Build traces
    const traces = [];
    traces.push({
      x, open, high, low, close,
      type: 'candlestick', name: 'Price', yaxis: 'y',
      increasing: {line: {color: css('--c-up')||'#16a34a'}},
      decreasing: {line: {color: css('--c-down')||'#dc2626'}},
      showlegend: false, hoverinfo: 'x+y',
    });
    if (els.toggles.querySelector('[data-k="SMA20"].active')) {
      traces.push({x, y: sma20, type: 'scatter', mode: 'lines', name: 'SMA 20', line: {color: css('--c-sma20')||'#22c55e', width:2}, yaxis: 'y', hoverinfo: 'x+y'});
    }
    if (els.toggles.querySelector('[data-k="SMA50"].active')) {
      traces.push({x, y: sma50, type: 'scatter', mode: 'lines', name: 'SMA 50', line: {color: css('--c-sma50')||'#60a5fa', width:2}, yaxis: 'y', hoverinfo: 'x+y'});
    }
    if (els.toggles.querySelector('[data-k="SMA200"].active')) {
      traces.push({x, y: sma200, type: 'scatter', mode: 'lines', name: 'SMA 200', line: {color: css('--c-sma200')||'#f59e0b', width:2}, yaxis: 'y', hoverinfo: 'x+y'});
    }
    // Ichimoku overlay
    if (els.toggles.querySelector('[data-k="ICHI"].active')) {
      const ichi = calcIchimoku(visibleRows);
      traces.push({x, y: ichi.tenkan, type: 'scatter', mode: 'lines', name: 'Tenkan', line: {color: css('--c-ichi-tenkan')||'#f59e0b', width:1.5, dash:'dot'}, yaxis: 'y', hoverinfo: 'x+y'});
      traces.push({x, y: ichi.kijun, type: 'scatter', mode: 'lines', name: 'Kijun', line: {color: css('--c-ichi-kijun')||'#60a5fa', width:1.5, dash:'dot'}, yaxis: 'y', hoverinfo: 'x+y'});
      traces.push({x, y: ichi.chikou, type: 'scatter', mode: 'lines', name: 'Chikou', line: {color: css('--c-ichi-chikou')||'#93c5fd', width:1.5, dash:'dot'}, yaxis: 'y', hoverinfo: 'x+y'});
      traces.push({x, y: ichi.spanA, type: 'scatter', mode: 'lines', name: 'Span A', line: {color: css('--c-ichi-up')||'rgba(34,197,94,.38)', width:0.5}, yaxis: 'y', hoverinfo: 'x+y', fill:'tonexty', fillcolor:css('--c-ichi-up')||'rgba(34,197,94,.38)'});
      traces.push({x, y: ichi.spanB, type: 'scatter', mode: 'lines', name: 'Span B', line: {color: css('--c-ichi-down')||'rgba(239,68,68,.34)', width:0.5}, yaxis: 'y', hoverinfo: 'x+y', fill:'tonexty', fillcolor:css('--c-ichi-down')||'rgba(239,68,68,.34)'});
    }
    await waitForPlotly();
    Plotly.newPlot(els.chart, traces, {margin:{t:40,l:60,r:30,b:60}, paper_bgcolor:css('--panel'), plot_bgcolor:css('--panel'), xaxis:{type:'date',gridcolor:css('--grid')}, yaxis:{gridcolor:css('--grid')}}, {responsive:true, displayModeBar:false});
    applyChartTheme();
    // Auto Fib overlay
    if (els.toggles.querySelector('[data-k="AUTOFIB"].active')) {
      addOrUpdateAutoFibTraces();
    } else {
      clearAutoFib();
    }
  }

  // Toggle chips -> re-render overlays (and keep candles)
  els.toggles.addEventListener('click', (e) => {
    const chip = e.target.closest('.chip');
    if (!chip) return;
    const k = chip.dataset.k;
    const nowOn = !chip.classList.contains('active');
    chip.classList.toggle('active', nowOn);

    // Auto Fib is shapes/annotations, handled live; others replot via updateChartOverlays()
    if (k === 'AUTOFIB') {
      if (nowOn) addOrUpdateAutoFibTraces();
      else clearAutoFib();
      return;
    }
    // Only update overlays, do NOT refresh price/info bar
    if (["SMA20","SMA50","SMA200","RSI","MACD","VOL","ICHI"].includes(k)) {
      updateChartOverlays();
    }
  });

  // Store last loaded visibleRows for overlay-only updates
  let LAST_VISIBLE_ROWS = [];

  // --- Overlay-only chart update (no info bar refresh) ---
  function updateChartOverlays() {
    if (!CURRENT.ticker || !LAST_VISIBLE_ROWS.length) return;
    const visibleRows = LAST_VISIBLE_ROWS;
    const x = visibleRows.map(r=>r.date);
    const open = visibleRows.map(r=>r.o);
    const high = visibleRows.map(r=>r.h);
    const low = visibleRows.map(r=>r.l);
    const close = visibleRows.map(r=>r.c);
    // --- indicators ---
    const sma20  = SMA(close, 20);
    const sma50  = SMA(close, 50);
    const sma200 = SMA(close, 200);
    const rsi = RSI(close, 14);
    const { macd, signal, hist } = MACD(close, 12, 26, 9);
    const traces = [];
    if (els.toggles.querySelector('[data-k="SMA20"].active))
      traces.push({ x, y: sma20,  type:'scatter', mode:'lines', name:'SMA 20',  line:{ width:1.8, color:css('--c-sma20')||'#22c55e' }, yaxis:'y', hoverinfo:'skip' });
    if (els.toggles.querySelector('[data-k="SMA50"].active))
      traces.push({ x, y: sma50,  type:'scatter', mode:'lines', name:'SMA 50',  line:{ width:1.8, color:css('--c-sma50')||'#60a5fa' }, yaxis:'y', hoverinfo:'skip' });
    if (els.toggles.querySelector('[data-k="SMA200"].active))
      traces.push({ x, y: sma200, type:'scatter', mode:'lines', name:'SMA 200', line:{ width:1.8, color:css('--c-sma200')||'#f59e0b' }, yaxis:'y', hoverinfo:'skip' });
    if (els.toggles.querySelector('[data-k="RSI"].active)) {
      traces.push({ x, y:rsi, type:'scatter', mode:'lines', name:'RSI', line:{ width:1.6, color:css('--c-rsi')||'#a78bfa' }, yaxis:'y2' });
      traces.push({ x:[x[0], x.at(-1)], y:[30,30], type:'scatter', mode:'lines', line:{ width:1, dash:'dot', color:'#64748b' }, yaxis:'y2', hoverinfo:'skip', showlegend:false });
      traces.push({ x:[x[0], x.at(-1)], y:[70,70], type:'scatter', mode:'lines', line:{ width:1, dash:'dot', color:'#64748b' }, yaxis:'y2', hoverinfo:'skip', showlegend:false });
    }
    if (els.toggles.querySelector('[data-k="VOL"].active)) {
      const vol = visibleRows.map(r=>r.v||0);
      traces.push({
        x, y: vol, type:'bar', name:'Volume', yaxis:'y3',
        marker:{ color: css('--c-vol')||'#10b981', opacity:.8 },
        hovertemplate:'Vol: %{y:,}<extra></extra>'
      });
    }
    if (els.toggles.querySelector('[data-k="MACD"].active)) {
      traces.push({ x, y: hist,   type:'bar',     name:'Hist',   yaxis:'y4', marker:{ color: css('--c-macd')||'#38bdf8', opacity:.7 }, hovertemplate:'%{y:.2f}<extra></extra>' });
      traces.push({ x, y: macd,   type:'scatter', mode:'lines',  name:'MACD', yaxis:'y4', line:{ width:1.6, color: css('--c-macd')||'#38bdf8' }});
      traces.push({ x, y: signal, type:'scatter', mode:'lines',  name:'Signal', yaxis:'y4', line:{ width:1.6, color:'#f97316' }});
    }
    if (els.toggles.querySelector('[data-k="ICHI"].active)) {
      const ichi = calcIchimoku(visibleRows);
      const { gLow, gUp, rLow, rUp } = segmentCloud(ichi.spanA, ichi.spanB);
      traces.push({ x, y:gLow, type:'scatter', mode:'lines', line:{width:0}, yaxis:'y', hoverinfo:'skip', showlegend:false });
      traces.push({ x, y:gUp,  type:'scatter', mode:'lines', fill:'tonexty', fillcolor:css('--c-ichi-up')||'rgba(34,197,94,.38)',  line:{width:0}, yaxis:'y', name:'Kumo+' });
      traces.push({ x, y:rLow, type:'scatter', mode:'lines', line:{width:0}, yaxis:'y', hoverinfo:'skip', showlegend:false });
      traces.push({ x, y:rUp,  type:'scatter', mode:'lines', fill:'tonexty', fillcolor:css('--c-ichi-down')||'rgba(239,68,68,.34)', line:{width:0}, yaxis:'y', name:'Kumo‚àí' });
      traces.push({ x, y:ichi.tenkan, type:'scatter', mode:'lines', name:'Tenkan', line:{ width:1.6, dash:'dot', color:css('--c-ichi-tenkan')||'#f59e0b' }, yaxis:'y' });
      traces.push({ x, y:ichi.kijun,  type:'scatter', mode:'lines', name:'Kijun',  line:{ width:1.6, dash:'dot', color:css('--c-ichi-kijun')||'#60a5fa' }, yaxis:'y' });
      traces.push({ x, y:ichi.chikou, type:'scatter', mode:'lines', name:'Chikou', line:{ width:1.2, dash:'dash',color:css('--c-ichi-chikou')||'#93c5fd' }, yaxis:'y' });
    }
    await Plotly.newPlot(els.chart, traces, { margin:{ t:40,l:60,r:30,b:60}, paper_bgcolor:css('--panel'), plot_bgcolor:css('--panel'), xaxis:{type:'date',gridcolor:css('--grid')}, yaxis:{gridcolor:css('--grid')}}, {responsive:true, displayModeBar:false});
    applyChartTheme();
    fitPriceAxisToCandlesStrict?.();
    // Auto Fib overlay
    if (els.toggles.querySelector('[data-k="AUTOFIB"].active')) {
      addOrUpdateAutoFibTraces();
    } else {
      clearAutoFib();
    }
  }

  // Chip toggles using Plotly.restyle for overlays
  let traceKeyMap = {};

  function updateTraceKeyMap() {
    // Map chip keys to trace indices after each newPlot
    traceKeyMap = {};
    if (!els.chart || !els.chart.data) return;
    els.chart.data.forEach((trace, i) => {
      if (trace.name === 'SMA 20') traceKeyMap['SMA20'] = i;
      if (trace.name === 'SMA 50') traceKeyMap['SMA50'] = i;
      if (trace.name === 'SMA 200') traceKeyMap['SMA200'] = i;
      if (trace.name === 'RSI') traceKeyMap['RSI'] = i;
      if (trace.name === 'MACD') traceKeyMap['MACD'] = i;
      if (trace.name === 'Signal') traceKeyMap['MACD_SIGNAL'] = i;
      if (trace.name === 'Volume') traceKeyMap['VOL'] = i;
      if (trace.name === 'Tenkan') traceKeyMap['ICHI_TENKAN'] = i;
      if (trace.name === 'Kijun') traceKeyMap['ICHI_KIJUN'] = i;
      if (trace.name === 'Chikou') traceKeyMap['ICHI_CHIKOU'] = i;
      if (trace.name === 'Kumo+') traceKeyMap['ICHI_KUMO_UP'] = i;
      if (trace.name === 'Kumo‚àí') traceKeyMap['ICHI_KUMO_DOWN'] = i;
    });
  }

  // Call updateTraceKeyMap after each newPlot
  // ...existing code in go() and updateChartOverlays...
await Plotly.newPlot(els.chart, traces, layout, { displayModeBar:false });
updateTraceKeyMap();

// Chip toggles only restyle overlays
els.toggles.addEventListener('click', (e) => {
  const chip = e.target.closest('.chip');
  if (!chip) return;
  const k = chip.dataset.k;
  const nowOn = !chip.classList.contains('active');
  chip.classList.toggle('active', nowOn);
  if (k === 'AUTOFIB') {
    if (nowOn) addOrUpdateAutoFibTraces();
    else clearAutoFib();
    return;
  }
  // Only restyle overlays, do not redraw chart
  if (traceKeyMap[k] !== undefined) {
    Plotly.restyle(els.chart, { visible: nowOn }, traceKeyMap[k]);
  }
});
  </script>

  <script>
  function showError(msg) {
    let errBox = document.getElementById('chart-error-box');
    if (!errBox) {
      errBox = document.createElement('div');
      errBox.id = 'chart-error-box';
      errBox.style.cssText = 'color:#fff;background:#c00;padding:8px 16px;margin:8px 0;border-radius:6px;font-weight:bold;text-align:center;z-index:10;';
      const chartParent = document.getElementById('chart')?.parentNode;
      if (chartParent) chartParent.insertBefore(errBox, document.getElementById('chart'));
      else document.body.prepend(errBox);
    }
    errBox.textContent = msg;
    errBox.style.display = 'block';
  }
  function clearError() {
    const errBox = document.getElementById('chart-error-box');
    if (errBox) errBox.style.display = 'none';
  }
  </script>
</body>
</html>
